"use strict";var Oe=Object.create;var F=Object.defineProperty;var Fe=Object.getOwnPropertyDescriptor;var He=Object.getOwnPropertyNames;var Ge=Object.getPrototypeOf,Ne=Object.prototype.hasOwnProperty;var S=(n,e)=>{for(var s in e)F(n,s,{get:e[s],enumerable:!0})},O=(n,e,s,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of He(e))!Ne.call(n,i)&&i!==s&&F(n,i,{get:()=>e[i],enumerable:!(o=Fe(e,i))||o.enumerable});return n},h=(n,e,s)=>(O(n,e,"default"),s&&O(s,e,"default")),ae=(n,e,s)=>(s=n!=null?Oe(Ge(n)):{},O(e||!n||!n.__esModule?F(s,"default",{value:n,enumerable:!0}):s,n)),_e=n=>O(F({},"__esModule",{value:!0}),n);var b={};S(b,{Bot:()=>z,BotSpecificClient:()=>w,Integration:()=>K,IntegrationDefinition:()=>C,IntegrationSpecificClient:()=>M,InterfaceDeclaration:()=>g,RuntimeError:()=>L.RuntimeError,botIdHeader:()=>A,botUserIdHeader:()=>W,configurationHeader:()=>R,integrationIdHeader:()=>Q,interfaces:()=>re,isApiError:()=>L.isApiError,messages:()=>H,operationHeader:()=>U,parseBody:()=>f,serve:()=>D,typeHeader:()=>Y,webhookIdHeader:()=>X});module.exports=_e(b);var H={};S(H,{defaults:()=>q});var r={};S(r,{default:()=>t});var ce=require("@bpinternal/zui");h(r,require("@bpinternal/zui"));var t=ce.z;var u=r.z.string().min(1),pe=r.z.object({text:u}),ge=r.z.object({markdown:u}),de=r.z.object({imageUrl:u}),me=r.z.object({audioUrl:u}),ue=r.z.object({videoUrl:u}),he=r.z.object({fileUrl:u,title:u.optional()}),Te=r.z.object({latitude:r.z.number(),longitude:r.z.number(),address:r.z.string().optional(),title:r.z.string().optional()}),fe=r.z.object({title:u,subtitle:u.optional(),imageUrl:u.optional(),actions:r.z.array(r.z.object({action:r.z.enum(["postback","url","say"]),label:u,value:u}))}),le=r.z.object({text:u,options:r.z.array(r.z.object({label:u,value:u}))}),Ke=r.z.object({items:r.z.array(fe)}),ze=r.z.discriminatedUnion("type",[r.z.object({type:r.z.literal("text"),payload:pe}),r.z.object({type:r.z.literal("markdown"),payload:ge}),r.z.object({type:r.z.literal("image"),payload:de}),r.z.object({type:r.z.literal("audio"),payload:me}),r.z.object({type:r.z.literal("video"),payload:ue}),r.z.object({type:r.z.literal("file"),payload:he}),r.z.object({type:r.z.literal("location"),payload:Te})]),Le=r.z.object({items:r.z.array(ze)}),q={text:{schema:pe},markdown:{schema:ge},image:{schema:de},audio:{schema:me},video:{schema:ue},file:{schema:he},location:{schema:Te},carousel:{schema:Ke},card:{schema:fe},dropdown:{schema:le},choice:{schema:le},bloc:{schema:Le}};var re={};S(re,{creatable:()=>ft,deletable:()=>It,hitl:()=>rt,listable:()=>Tt,llm:()=>gt,readable:()=>bt,schemas:()=>J,speechToText:()=>ut,textToImage:()=>Bt,typingIndicator:()=>St,updatable:()=>yt});var J={};S(J,{speechToText:()=>$});var $={};S($,{OpenAITranscribeAudioOutputSchema:()=>V});var V=t.object({language:t.string().describe("Detected language of the audio"),duration:t.number().describe("Duration of the audio file, in seconds"),segments:t.array(t.object({text:t.string().describe("Text content of the segment."),id:t.number().describe("Unique identifier of the segment"),seek:t.number().describe("Seek offset of the segment"),start:t.number().describe("Start time of the segment in seconds."),end:t.number().describe("End time of the segment in seconds."),tokens:t.array(t.number()).describe("Array of token IDs for the text content."),temperature:t.number().describe("Temperature parameter used for generating the segment."),avg_logprob:t.number().describe("Average logprob of the segment. If the value is lower than -1, consider the logprobs failed."),compression_ratio:t.number().describe("Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed."),no_speech_prob:t.number().describe("Probability of no speech in the segment. If the value is higher than 1.0 and the avg_logprob is below -1, consider this segment silent.")}))});var be=require("@bpinternal/zui");var A="x-bot-id",W="x-bot-user-id",Q="x-integration-id",X="x-webhook-id",R="x-bp-configuration",U="x-bp-operation",Y="x-bp-type";var Ze=be.z.enum(["webhook_received","message_created","action_triggered","register","unregister","ping","create_user","create_conversation"]),ye=n=>{let e=n[A],s=n[W],o=n[Q],i=n[X],a=n[R],c=Ze.parse(n[U]);if(!e)throw new Error("Missing bot headers");if(!s)throw new Error("Missing bot user headers");if(!o)throw new Error("Missing integration headers");if(!i)throw new Error("Missing webhook headers");if(!a)throw new Error("Missing configuration headers");if(!c)throw new Error("Missing operation headers");return{botId:e,botUserId:s,integrationId:o,webhookId:i,operation:c,configuration:a?JSON.parse(Buffer.from(a,"base64").toString("utf-8")):{}}};var qe=n=>Array.from(new Set(n)),I=n=>Object.entries(n);var x=(n,e)=>Object.fromEntries(I(n).map(([s,o])=>[s,e(o,s)])),k=(n,e,s)=>{let o=qe([...Object.keys(n),...Object.keys(e)]),i={};for(let a of o){let c=n[a],p=e[a];c&&p?i[a]=s(c,p):c?i[a]=c:p&&(i[a]=p)}return i};var te=Symbol("schemaName"),Ie=n=>n?x(n,(s,o)=>({...s,[te]:o})):{},ve=n=>n[te]!==void 0,xe=n=>n[te];var C=class{constructor(e){this.props=e;this.name=e.name,this.version=e.version,this.icon=e.icon,this.readme=e.readme,this.title=e.title,this.identifier=e.identifier,this.description=e.description,this.configuration=e.configuration,this.events=e.events,this.actions=e.actions,this.channels=e.channels,this.states=e.states,this.user=e.user,this.secrets=e.secrets,this.entities=e.entities}name;version;title;description;icon;readme;configuration;events;actions;channels;states;user;secrets;identifier;entities;interfaces={};clone(e){let s=new C({...this,...e});for(let[o,i]of Object.entries(this.interfaces))s.interfaces[o]=i;return s}extend(e,s){let o=s(Ie(this.entities)),i=I(o).find(([m,v])=>!ve(v));if(i)throw new Error(`Cannot extend interface "${e.name}" with entity "${i[0]}"; the provided schema is not part of the integration's entities.`);let a=x(o,m=>({name:xe(m),schema:m.schema})),{resolved:c,implementStatement:p}=e.resolve({entities:a}),l=this;l.actions=k(l.actions??{},c.actions,this._mergeActions),l.channels=k(l.channels??{},c.channels,this._mergeChannels),l.events=k(l.events??{},c.events,this._mergeEvents);let d=Object.values(a).map(m=>m.name),T=d.length===0?e.name:`${e.name}<${d.join(",")}>`;return this.interfaces[T]=p,this}_mergeActions=(e,s)=>({title:s.title??e.title,description:s.description??e.description,input:{schema:e.input.schema.merge(s.input.schema)},output:{schema:e.output.schema.merge(s.output.schema)}});_mergeEvents=(e,s)=>({title:s.title??e.title,description:s.description??e.description,schema:e.schema.merge(s.schema)});_mergeChannels=(e,s)=>{let o=k(e.messages,s.messages,this._mergeMessage);return{title:s.title??e.title,description:s.description??e.description,conversation:s.conversation??e.conversation,message:s.message??e.message,messages:o}};_mergeMessage=(e,s)=>({schema:e.schema.merge(s.schema)})};var g=class{constructor(e){this.props=e;this.name=e.name,this.version=e.version,this.entities=e.entities??{},this.events=e.events??{},this.actions=e.actions??{},this.channels=e.channels??{},this.templateName=e.templateName}name;version;entities;events;actions;channels;templateName;resolve(e){let{entities:s}=e,o={name:this.name,version:this.version,entities:x(s,l=>({name:l.name})),actions:{},events:{}},i={},a={},c={};for(let[l,d]of I(this.actions)){let T=this._dereference(d.input.schema,s),m=this._dereference(d.output.schema,s),v=this._rename(s,l);i[v]={input:{schema:T},output:{schema:m}},o.actions[l]={name:v}}for(let[l,d]of I(this.events)){let T=this._dereference(d.schema,s),m=this._rename(s,l);a[m]={schema:T},o.events[l]={name:m}}for(let[l,d]of I(this.channels)){let T={};for(let[m,v]of I(d.messages)){let Z=this._dereference(v.schema,s);T[m]={schema:Z}}c[l]={messages:T}}return{resolved:{actions:i,events:a,channels:c},implementStatement:o}}_dereference(e,s){let o={},i={};for(let[a,c]of I(s))o[a]=c.schema,i[a]=t.ref(a);return e(i).dereference(o)}_rename(e,s){if(!this.templateName)return s;let o=x(e,i=>i.name);return this.templateName(s,o)}};var Be=require("node:http");var E=console;function f(n){if(!n.body)throw new Error("Missing body");return JSON.parse(n.body)}async function D(n,e=8072,s=We){let o=(0,Be.createServer)(async(i,a)=>{try{let c=await Ve(i);if(c.path==="/health"){a.writeHead(200).end("ok");return}let p=await n(c);a.writeHead(p?.status??200,p?.headers??{}).end(p?.body??"{}")}catch(c){E.error("Error while handling request",{error:c?.message??"Internal error occured"}),a.writeHead(500).end(JSON.stringify({error:c?.message??"Internal error occured"}))}});return o.listen(e,()=>s(e)),o}async function Ve(n){let e=await Je(n),s={};for(let i=0;i<n.rawHeaders.length;i+=2){let a=n.rawHeaders[i].toLowerCase(),c=n.rawHeaders[i+1];s[a]=c}let o=new URL(n.url??"",n.headers.host?`http://${n.headers.host}`:"http://botpress.cloud");return{body:e,path:o.pathname,query:$e(o.search,"?"),headers:s,method:n.method?.toUpperCase()??"GET"}}function $e(n,e){return n.indexOf(e)===0?n.slice(e.length):n}async function Je(n){return new Promise((e,s)=>{if(n.method!=="POST"&&n.method!=="PUT"&&n.method!=="PATCH")return e(void 0);let o="";n.on("data",i=>o+=i.toString()),n.on("error",i=>s(i)),n.on("end",()=>e(o))})}function We(n){E.info(`Listening on port ${n}`)}var B=require("@botpress/client");var Se=require("@botpress/client"),G={retries:3,retryCondition:n=>Se.axiosRetry.isNetworkOrIdempotentRequestError(n)||[429,502].includes(n.response?.status??0),retryDelay:n=>n*1e3};var M=class{constructor(e){this.client=e}createConversation=e=>this.client.createConversation(e);getConversation=e=>this.client.getConversation(e);listConversations=e=>this.client.listConversations(e);getOrCreateConversation=e=>this.client.getOrCreateConversation(e);updateConversation=e=>this.client.updateConversation(e);deleteConversation=e=>this.client.deleteConversation(e);listParticipants=e=>this.client.listParticipants(e);addParticipant=e=>this.client.addParticipant(e);getParticipant=e=>this.client.getParticipant(e);removeParticipant=e=>this.client.removeParticipant(e);createEvent=e=>this.client.createEvent(e);getEvent=e=>this.client.getEvent(e);listEvents=e=>this.client.listEvents(e);createMessage=e=>this.client.createMessage(e);getOrCreateMessage=e=>this.client.getOrCreateMessage(e);getMessage=e=>this.client.getMessage(e);updateMessage=e=>this.client.updateMessage(e);listMessages=e=>this.client.listMessages(e);deleteMessage=e=>this.client.deleteMessage(e);createUser=e=>this.client.createUser(e);getUser=e=>this.client.getUser(e);listUsers=e=>this.client.listUsers(e);getOrCreateUser=e=>this.client.getOrCreateUser(e);updateUser=e=>this.client.updateUser(e);deleteUser=e=>this.client.deleteUser(e);getState=e=>this.client.getState(e);setState=e=>this.client.setState(e);getOrSetState=e=>this.client.getOrSetState(e);patchState=e=>this.client.patchState(e);configureIntegration=e=>this.client.configureIntegration(e);uploadFile=e=>this.client.uploadFile(e);upsertFile=e=>this.client.upsertFile(e);deleteFile=e=>this.client.deleteFile(e);listFiles=e=>this.client.listFiles(e);getFile=e=>this.client.getFile(e);updateFileMetadata=e=>this.client.updateFileMetadata(e)};var ne=ae(require("util")),N=n=>{if(process.env.BP_LOG_FORMAT==="json")return JSON.stringify({msg:ne.default.format(...n),visible_to_bot_owner:!0});{let[e,...s]=n;return ne.default.format(`[For Bot Owner] ${e}`,...s)}},_={forBot:()=>({info:(...n)=>{console.info(N(n))},warn:(...n)=>{console.warn(N(n))},error:(...n)=>{console.error(N(n))},debug:(...n)=>{console.debug(N(n))}})};var Ce=n=>async e=>{let s=ye(e.headers),o=new B.Client({botId:s.botId,integrationId:s.integrationId,retry:G}),i=new M(o),a={ctx:s,req:e,client:i,logger:_,instance:n};try{let c;switch(s.operation){case"webhook_received":c=await Xe(a);break;case"register":c=await Ye(a);break;case"unregister":c=await et(a);break;case"message_created":c=await st(a);break;case"action_triggered":c=await ot(a);break;case"ping":c=await Qe(a);break;case"create_user":c=await tt(a);break;case"create_conversation":c=await nt(a);break;default:throw new Error(`Unknown operation ${s.operation}`)}return c?{...c,status:c.status??200}:{status:200}}catch(c){if((0,B.isApiError)(c)){let l=new B.RuntimeError(c.message,c);return _.forBot().error(l.message),{status:l.code,body:JSON.stringify(l.toJSON())}}console.error(c);let p=new B.RuntimeError("An unexpected error occurred in the integration. Bot owners: Check logs for more informations. Integration owners: throw a RuntimeError to return a custom error message instead.");return _.forBot().error(p.message),{status:p.code,body:JSON.stringify(p.toJSON())}}},Qe=async n=>{},Xe=async({client:n,ctx:e,req:s,logger:o,instance:i})=>{let{req:a}=f(s);return i.webhook({client:n,ctx:e,req:a,logger:o})},Ye=async({client:n,ctx:e,req:s,logger:o,instance:i})=>{if(!i.register)return;let{webhookUrl:a}=f(s);await i.register({client:n,ctx:e,webhookUrl:a,logger:o})},et=async({client:n,ctx:e,req:s,logger:o,instance:i})=>{if(!i.unregister)return;let{webhookUrl:a}=f(s);await i.unregister({ctx:e,webhookUrl:a,client:n,logger:o})},tt=async({client:n,ctx:e,req:s,logger:o,instance:i})=>{if(!i.createUser)return;let{tags:a}=f(s);return await i.createUser({ctx:e,client:n,tags:a,logger:o})},nt=async({client:n,ctx:e,req:s,logger:o,instance:i})=>{if(!i.createConversation)return;let{channel:a,tags:c}=f(s);return await i.createConversation({ctx:e,client:n,channel:a,tags:c,logger:o})},st=async({ctx:n,req:e,client:s,logger:o,instance:i})=>{let{conversation:a,user:c,type:p,payload:l,message:d}=f(e),T=i.channels[a.channel];if(!T)throw new Error(`Channel ${a.channel} not found`);let m=T.messages[p];if(!m)throw new Error(`Message of type ${p} not found in channel ${a.channel}`);await m({ctx:n,conversation:a,message:d,user:c,type:p,client:s,payload:l,ack:async({tags:Z})=>{await s.updateMessage({id:d.id,tags:Z})},logger:o})},ot=async({req:n,ctx:e,client:s,logger:o,instance:i})=>{let{input:a,type:c}=f(n);if(!c)throw new Error("Missing action type");let p=i.actions[c];if(!p)throw new Error(`Action ${c} not found`);let l=await p({ctx:e,input:a,client:s,type:c,logger:o});return{body:JSON.stringify({output:l})}};var K=class{props;actions;channels;register;unregister;createUser;createConversation;webhook;constructor(e){this.props=e,this.actions=e.actions,this.channels=e.channels,this.register=e.register,this.unregister=e.unregister,this.createUser=e.createUser,this.createConversation=e.createConversation,this.webhook=e.handler}handler=Ce(this);start=e=>D(this.handler,e)};var it=n=>({...n,schema:()=>n.schema.extend({userId:t.string().optional().describe("Allows sending a message pretending to be a certain user")})}),rt=new g({name:"hitl",version:"0.2.0",entities:{},events:{hitlAssigned:{schema:()=>t.object({conversationId:t.string(),userId:t.string()})},hitlStopped:{schema:()=>t.object({conversationId:t.string()})}},actions:{createUser:{input:{schema:()=>t.object({name:t.string().optional(),pictureUrl:t.string().optional(),email:t.string().optional()})},output:{schema:()=>t.object({userId:t.string()})}},startHitl:{input:{schema:()=>t.object({userId:t.string(),title:t.string(),description:t.string().optional()})},output:{schema:()=>t.object({conversationId:t.string()})}},stopHitl:{input:{schema:()=>t.object({conversationId:t.string(),reason:t.enum(["timeout","cancel"]).optional()})},output:{schema:()=>t.object({})}}},channels:{hitl:{messages:{text:it(q.text)}}}});var at=t.object({id:t.string(),type:t.enum(["function"]),function:t.object({name:t.string(),arguments:t.record(t.any()).nullable().describe("Some LLMs may generate invalid JSON for a tool call, so this will be `null` when it happens.")})}),ct=t.object({type:t.enum(["auto","specific","any","none",""]).optional(),functionName:t.string().optional().describe('Required if `type` is "specific"')}),Ee=t.object({role:t.enum(["user","assistant"]),type:t.enum(["text","tool_calls","tool_result","multipart"]).default("text"),toolCalls:t.array(at).optional().describe('Required if `type` is "tool_calls"'),toolResultCallId:t.string().optional().describe('Required if `type` is "tool_result"'),content:t.string().or(t.array(t.object({type:t.enum(["text","image"]),mimeType:t.string().optional().describe("Indicates the MIME type of the content. If not provided it will be detected from the content-type header of the provided URL."),text:t.string().optional().describe('Required if part type is "text" '),url:t.string().optional().describe('Required if part type is "image"')}))).optional().nullable().describe('Required unless `type` is "tool_call". If `type` is "multipart", this field must be an array of content objects. If `type` is "tool_result" then this field should be the result of the tool call (a plain string or a JSON-encoded array or object). If `type` is "tool_call" then the `toolCalls` field should be used instead.')}),se=t.object({id:t.string()}),lt=se.extend({name:t.string(),description:t.string(),tags:t.array(t.enum(["recommended","deprecated","general-purpose","low-cost","vision","coding","agents","function-calling","roleplay","storytelling"])),input:t.object({maxTokens:t.number().int(),costPer1MTokens:t.number().describe("Cost per 1 million tokens, in U.S. dollars")}),output:t.object({maxTokens:t.number().int(),costPer1MTokens:t.number().describe("Cost per 1 million tokens, in U.S. dollars")})}),Me=n=>t.object({model:n.describe("Model to use for content generation").optional(),systemPrompt:t.string().optional().describe("Optional system prompt to guide the model"),messages:t.array(Ee).describe("Array of messages for the model to process"),responseFormat:t.enum(["text","json_object"]).optional().describe('Response format expected from the model. If "json_object" is chosen, you must instruct the model to generate JSON either via the system prompt or a user message.'),maxTokens:t.number().optional().describe("Maximum number of tokens allowed in the generated response"),temperature:t.number().min(0).max(2).displayAs({id:"slider",params:{stepSize:.01,horizontal:!0}}).default(1).describe("Sampling temperature for the model. Higher values result in more random outputs."),topP:t.number().min(0).max(1).default(1).displayAs({id:"slider",params:{stepSize:.01,horizontal:!0}}).describe("Top-p sampling parameter. Limits sampling to the smallest set of tokens with a cumulative probability above the threshold."),stopSequences:t.array(t.string()).max(4).optional().describe("Sequences where the model should stop generating further tokens."),tools:t.array(t.object({type:t.literal("function"),function:t.object({name:t.string().describe("Function name"),description:t.string().optional(),argumentsSchema:t.object({}).passthrough().optional().describe("JSON schema of the function arguments")})})).optional(),toolChoice:ct.optional(),userId:t.string().optional(),debug:t.boolean().optional().describe("Set to `true` to output debug information to the bot logs")}),Fn=Me(se),pt=t.object({id:t.string().describe("Response ID from LLM provider"),provider:t.string().describe("LLM provider name"),model:t.string().describe("Model name"),choices:t.array(Ee.omit({role:!0}).extend({role:t.literal("assistant"),index:t.number().int(),stopReason:t.enum(["stop","max_tokens","tool_calls","content_filter","other"])})),usage:t.object({inputTokens:t.number().int().describe("Number of input tokens used by the model"),inputCost:t.number().describe("Cost of the input tokens received by the model, in U.S. dollars"),outputTokens:t.number().int().describe("Number of output tokens used by the model"),outputCost:t.number().describe("Cost of the output tokens generated by the model, in U.S. dollars")}),botpress:t.object({cost:t.number().describe("Total cost of the content generation, in U.S. dollars")})}),gt=new g({name:"llm",version:"5.0.0",entities:{modelRef:{schema:se}},events:{},actions:{generateContent:{billable:!0,cacheable:!0,input:{schema:({modelRef:n})=>Me(n)},output:{schema:()=>pt}},listLanguageModels:{input:{schema:()=>t.object({})},output:{schema:({modelRef:n})=>t.object({models:t.array(t.intersection(lt,n))})}}}});var oe=t.object({id:t.string()}),dt=oe.extend({name:t.string(),costPerMinute:t.number().describe("Cost per minute of speech transcription, in U.S. dollars")}),Pe=n=>t.object({model:n.optional().describe("Model to use for speech-to-text transcription (optional)"),fileUrl:t.string().url().describe("URL of the audio file to transcribe. The URL should return a content-type header in order to detect the audio format. Supported audio formats supported are: mp3, mp4, mpeg, mpga, m4a, wav, webm"),language:t.string().optional().describe("The language of the input audio (optional). Supplying the input language in ISO-639-1 format will improve accuracy and latency."),prompt:t.string().optional().describe("An optional text to guide the model's style or continue a previous audio segment. The prompt should match the audio language."),temperature:t.number().default(0).optional().describe("The sampling temperature (optional), between 0 and 1. Defaults to 0 (automatic). Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.")}),Kn=Pe(oe),mt=V.extend({model:t.string().describe("Model name used"),cost:t.number().optional().describe("Total cost of the transcription, in U.S. dollars (DEPRECATED)"),botpress:t.object({cost:t.number().describe("Total cost of the transcription, in U.S. dollars")})}),ut=new g({name:"speechToText",version:"2.0.0",entities:{speechToTextModelRef:{schema:oe}},actions:{transcribeAudio:{billable:!0,cacheable:!0,input:{schema:({speechToTextModelRef:n})=>Pe(n)},output:{schema:()=>mt}},listSpeechToTextModels:{input:{schema:()=>t.object({})},output:{schema:({speechToTextModelRef:n})=>t.object({models:t.array(t.intersection(dt,n))})}}}});var y=t.object({id:t.string()}),P=n=>t.intersection(n,y),ht=n=>n[0].toUpperCase()+n.slice(1),j=(...n)=>{let[e,...s]=n.filter(o=>o.length>0).map(o=>o.toLowerCase());return e?[e,...s.map(ht)].join(""):""},we=t.string().optional(),Tt=new g({name:"listable",version:"0.0.1",entities:{item:{schema:y}},events:{},actions:{list:{input:{schema:()=>t.object({nextToken:we})},output:{schema:n=>t.object({items:t.array(P(n.item)),meta:t.object({nextToken:we})})}}},templateName:(n,e)=>j(e.item,n)}),ft=new g({name:"creatable",version:"0.0.1",entities:{item:{schema:y}},events:{created:{schema:n=>t.object({item:P(n.item)})}},actions:{create:{input:{schema:n=>t.object({item:n.item})},output:{schema:n=>t.object({item:P(n.item)})}}},templateName:(n,e)=>j(e.item,n)}),bt=new g({name:"readable",version:"0.0.1",entities:{item:{schema:y}},events:{},actions:{read:{input:{schema:()=>y},output:{schema:n=>t.object({item:P(n.item)})}}},templateName:(n,e)=>j(e.item,n)}),yt=new g({name:"updatable",version:"0.0.1",entities:{item:{schema:y}},events:{updated:{schema:n=>t.object({item:P(n.item)})}},actions:{update:{input:{schema:n=>y.extend({item:n.item})},output:{schema:n=>t.object({item:P(n.item)})}}},templateName:(n,e)=>j(e.item,n)}),It=new g({name:"deletable",version:"0.0.1",entities:{item:{schema:y}},events:{deleted:{schema:()=>y}},actions:{delete:{input:{schema:()=>y},output:{schema:()=>t.object({})}}},templateName:(n,e)=>j(e.item,n)});var ie=t.object({id:t.string()}),vt=ie.extend({name:t.string(),costPerImage:t.number().describe("Cost per image generation, in U.S. dollars"),sizes:t.array(t.string()).describe("Available image sizes"),defaultSize:t.string().describe("Default image size generated by model")}),Ae=t.object({}).describe("Model-specific parameters for image generation"),Re=(n,e)=>t.object({model:n.optional().describe("Model to use for image generation"),prompt:t.string(),size:t.string().optional(),expiration:t.number().int().min(30).max(90).optional().describe("Expiration of the generated image in days, after which the image will be automatically deleted to free up storage space in your account. The default is to keep the image indefinitely (no expiration). The minimum is 30 days and the maximum is 90 days."),params:e.optional()}),Jn=Re(ie,Ae),xt=t.object({model:t.string().describe("Model name used"),imageUrl:t.string().describe("Temporary URL of generated image"),cost:t.number().optional().describe("Cost of the image generation, in U.S. dollars (DEPRECATED)"),botpress:t.object({cost:t.number().describe("Cost of the image generation, in U.S. dollars")})}),Bt=new g({name:"textToImage",version:"2.1.0",entities:{imageModelRef:{schema:ie},imageGenerationParams:{schema:Ae}},actions:{generateImage:{billable:!0,cacheable:!0,input:{schema:({imageModelRef:n,imageGenerationParams:e})=>Re(n,e)},output:{schema:()=>xt}},listImageModels:{input:{schema:()=>t.object({})},output:{schema:({imageModelRef:n})=>t.object({models:t.array(t.intersection(vt,n))})}}}});var St=new g({name:"typingIndicator",version:"0.0.1",entities:{},events:{},actions:{startTypingIndicator:{input:{schema:()=>t.object({conversationId:t.string(),messageId:t.string().describe("The message ID to which the typing indicator should be attached"),timeout:t.number().optional().describe("The timeout in milliseconds after which the typing indicator should stop")})},output:{schema:()=>t.object({})}},stopTypingIndicator:{input:{schema:()=>t.object({conversationId:t.string(),messageId:t.string().describe("The message ID from which the typing indicator should be removed")})},output:{schema:()=>t.object({})}}}});h(b,r,module.exports);var L=require("@botpress/client");var De=ae(require("@botpress/client"));var w=class{constructor(e){this.client=e}getConversation=e=>this.client.getConversation(e);listConversations=e=>this.client.listConversations(e);updateConversation=e=>this.client.updateConversation(e);deleteConversation=e=>this.client.deleteConversation(e);listParticipants=e=>this.client.listParticipants(e);addParticipant=e=>this.client.addParticipant(e);getParticipant=e=>this.client.getParticipant(e);removeParticipant=e=>this.client.removeParticipant(e);getEvent=e=>this.client.getEvent(e);listEvents=e=>this.client.listEvents(e);createMessage=e=>this.client.createMessage(e);getOrCreateMessage=e=>this.client.getOrCreateMessage(e);getMessage=e=>this.client.getMessage(e);updateMessage=e=>this.client.updateMessage(e);listMessages=e=>this.client.listMessages(e);deleteMessage=e=>this.client.deleteMessage(e);getUser=e=>this.client.getUser(e);listUsers=e=>this.client.listUsers(e);updateUser=e=>this.client.updateUser(e);deleteUser=e=>this.client.deleteUser(e);getState=e=>this.client.getState(e).then(s=>({state:{...s.state,payload:s.state.payload}}));setState=e=>this.client.setState(e).then(s=>({state:{...s.state,payload:s.state.payload}}));getOrSetState=e=>this.client.getOrSetState(e).then(s=>({state:{...s.state,payload:s.state.payload}}));patchState=e=>this.client.patchState(e).then(s=>({state:{...s.state,payload:s.state.payload}}));callAction=e=>this.client.callAction(e);uploadFile=e=>this.client.uploadFile(e);upsertFile=e=>this.client.upsertFile(e);deleteFile=e=>this.client.deleteFile(e);listFiles=e=>this.client.listFiles(e);getFile=e=>this.client.getFile(e);updateFileMetadata=e=>this.client.updateFileMetadata(e);searchFiles=e=>this.client.searchFiles(e);createConversation=e=>this.client.createConversation(e);getOrCreateConversation=e=>this.client.getOrCreateConversation(e);createUser=e=>this.client.createUser(e);getOrCreateUser=e=>this.client.getOrCreateUser(e)};var Ue=require("@bpinternal/zui");var Ct=Ue.z.enum(["event_received","register","unregister","ping","action_triggered"]),ke=n=>{let e=n[A],s=n[R],o=n[Y],i=Ct.parse(n[U]);if(!e)throw new Error("Missing bot headers");if(!o)throw new Error("Missing type headers");if(!s)throw new Error("Missing configuration headers");if(!i)throw new Error("Missing operation headers");return{botId:e,operation:i,type:o,configuration:s?JSON.parse(Buffer.from(s,"base64").toString("utf-8")):{}}};var je=n=>async e=>{let s=ke(e.headers);s.operation!=="ping"&&E.info(`Received ${s.operation} operation for bot ${s.botId} of type ${s.type}`);let o=new De.Client({botId:s.botId,retry:G}),i=new w(o),a={req:e,ctx:s,client:i,instance:n};switch(s.operation){case"action_triggered":throw new Error(`Operation ${s.operation} not supported yet`);case"event_received":await wt(a);break;case"register":await Mt(a);break;case"unregister":await Pt(a);break;case"ping":await Et(a);break;default:throw new Error(`Unknown operation ${s.operation}`)}return{status:200}},Et=async n=>{},Mt=async n=>{},Pt=async n=>{},wt=async({ctx:n,req:e,client:s,instance:o})=>{E.debug(`Received event ${n.type}`);let i=f(e),a=i.event;switch(n.type){case"message_created":let c={user:a.payload.user,conversation:a.payload.conversation,message:a.payload.message,states:a.payload.states,event:a};await Promise.all(o.messageHandlers.map(d=>d({client:s,ctx:n,...c})));break;case"state_expired":let p={state:a.payload.state};await Promise.all(o.stateExpiredHandlers.map(d=>d({client:s,ctx:n,...p})));break;default:let l={event:i.event};await Promise.all(o.eventHandlers.map(d=>d({client:s,ctx:n,...l})))}};var z=class{_state={messageHandlers:[],eventHandlers:[],stateExpiredHandlers:[]};props;constructor(e){this.props=e}message=e=>{this._state.messageHandlers.push(e)};event=e=>{this._state.eventHandlers.push(e)};stateExpired=e=>{this._state.stateExpiredHandlers.push(e)};handler=je(this._state);start=e=>D(this.handler,e)};0&&(module.exports={Bot,BotSpecificClient,Integration,IntegrationDefinition,IntegrationSpecificClient,InterfaceDeclaration,RuntimeError,botIdHeader,botUserIdHeader,configurationHeader,integrationIdHeader,interfaces,isApiError,messages,operationHeader,parseBody,serve,typeHeader,webhookIdHeader});
//# sourceMappingURL=index.js.map
